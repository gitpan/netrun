.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "NETRUN 1"
.TH NETRUN 1 " " " " " "
.SH "NAME"
netrun \- run a script over multiple hosts in parallel
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBnetrun\fR  [\fB\-hqRS]\fR] [\fB\-c\fR \fIconnect timeout\fR] [\fB\-f\fR \fImax forks\fR] [\fB\-i\fR \fIinterpreter\fR] [\fB\-s\fR \fIscript file\fR] | [\fB\-e\fR \fIscript\fR] [\fB\-d\fR \fIdata file\fR] [\fB\-l\fR \fIlogin name\fR] [\fB\-L\fR \fIlog dir\fR] [\fB\-t\fR \fItimeout\fR] hosts ...
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBNetrun\fR provides a convenient and efficient way to run a single
command or a script on a bunch of remote hosts.  \fBNetrun\fR captures
the output and error messages from the command or script for reporting
and examination.
.PP
\&\fBNetrun\fR is powered by \f(CW\*(C`ssh\*(C'\fR and assumes that you have a setup like
the following:
.IP "\(bu" 4
You have created an \s-1SSH\s0 public/private key pair using \f(CW\*(C`ssh\-keygen\*(C'\fR.
.IP "\(bu" 4
You have copied your public key(s) to \f(CW\*(C`$HOME/.ssh/authorized_keys\*(C'\fR on
all of the remote hosts on which you plan to run commands or scripts
with \fBnetrun\fR.  If you plan to access remote hosts with different
accounts, you'll need to make sure that your public key(s) have been
added to each account's authorized_keys file.  Be sure to check your
local computer security policy and to get permission from the affected
users before doing this!
.IP "\(bu" 4
You have started an \f(CW\*(C`ssh\-agent\*(C'\fR and loaded your private keys with
\&\f(CW\*(C`ssh\-add\*(C'\fR.  Note that you can avoid having to run \f(CW\*(C`ssh\-agent\*(C'\fR by
creating private keys with no passphrase.  Please do not do this!  At
many sites, this is grounds for disciplinary action (especially if the
corresponding public keys are added to root's authorized_keys files).
.PP
For each hostname, \s-1IP\s0 address, or \s-1CIDR\s0 style subnet given on the
command\-line, \fBnetrun\fR performs the following steps:
.IP "1." 4
Connects to port 22 and captures the \s-1SSH\s0 version string.  This is done
to verify that the remote sshd is up and accessible.  Hosts will be
skipped if this step takes longer than 15 seconds (or the connection
timeout specified by \fB\-c\fR) to complete.
.IP "2." 4
Attempts to establish an \s-1SSH\s0 connection and run an interpreter (the
default is /bin/sh).
.IP "3." 4
Feeds the script file (specified with \fB\-s\fR) or command string
(specified with \fB\-e\fR) and an optional data file (specified with
\&\fB\-d\fR) to the standard input of the interpreter.
.IP "4." 4
Captures stdout and stderr of the interpreter to log files.  By
default, these log files are stored in \f(CW\*(C`./netrun.PID\*(C'\fR, however an
alternate log directory may be specified via \fB\-L\fR.  If the user
running netrun does not have both write and search permissions to the
log directory, \fBnetrun\fR exits with an error message.
.IP "5." 4
Displays a report that summarizes the status of the attempted actions.
A copy of this summary is also saved in \fIlogdir\fR/netrun.summary.
.PP
\&\fBNetrun\fR runs these steps on at most 25 hosts (by default) at a time.
The level of parallelism can be adjusted using \fB\-f\fR.  The status
report that is displayed once all of the parallel jobs have completed
includes the following information:
.IP "Name/Address" 4
.IX Item "Name/Address"
The hostname or \s-1IP\s0 address used to connect/login to the remote host
.IP "Exit" 4
.IX Item "Exit"
The exit status of the ssh process (if an \s-1SSH\s0 connection was made).
Usually, this is the exit status of the interpreter that was run on
the remote system; however, the ssh program uses 255 to indicate that
an error occurred while trying to establish the connection.  A \-1 exit
status indicates that the remote script failed to complete before the
timeout specified with \fB\-t\fR.
.IP "Runtime" 4
.IX Item "Runtime"
The time in seconds required to ssh into the remote host and run the
specified script or commands.
.IP "# Lines" 4
.IX Item "# Lines"
The number of lines of output produced by the remote script.  This
does not include lines written to stderr.
.IP "First Line of Output" 4
.IX Item "First Line of Output"
The first 30 or so bytes of the first line of output from the remote script.
.PP
If no script is specified (with \fB\-s\fR or \fB\-e\fR) on the command\-line,
\&\fBnetrun\fR skips steps 2 \- 4 above and just displays the status of
the connection to the \s-1SSH\s0 port.  Steps 2 \- 4 are also skipped if
\&\fBnetrun\fR is unable to connect to the \s-1SSH\s0 port and retrieve the \s-1SSH\s0
version string from the remote host.
.PP
While \fBnetrun\fR does not actually use the \s-1SSH\s0 version string, it
retrieves it to verify that an \s-1SSH\s0 connection to the remote host is
possible and is not being blocked by hosts.allow, etc.  This prevents
background processes from being tied up on ssh connections that can
never succeed.
.Sh "\s-1OPTIONS\s0"
.IX Subsection "OPTIONS"
.IP "\fB\-h\fR" 4
.IX Item "-h"
Display a brief summary of the command-line options.
.IP "\fB\-q\fR" 4
.IX Item "-q"
In Quick mode, \fBnetrun\fR simply dumps script/command results from
remote hosts to standard out.  Each line is prefixed with the hostname
or \s-1IP\s0 address of the host from which the output came.  Hosts that fail
to respond or to produce any output are excluded from the output.
Also, log files are removed automatically.
.Sp
This mode is handy for running a command or script on a bunch of hosts
and grep'ing the output.
.IP "\fB\-R\fR" 4
.IX Item "-R"
Don't randomize the hosts list.  By default, all hosts and \s-1CIDR\s0
addresses are expanded and randomized.  This evens out performance by
creating a mix of slow and fast remote hosts.  Specify \fB\-R\fR if you
need \fBnetrun\fR to preserve the order of the hosts specified on the
command\-line.
.IP "\fB\-S\fR" 4
.IX Item "-S"
Slow start.  By default, \fBnetrun\fR starts new processes as fast as it
can, but when running large numbers of background processes (see
\&\fB\-f\fR), this can quickly overwhelm even a powerful workstation and may
also trigger DoS settings in corporate firewalls.  This option adds a
1/4 second sleep between each process start to pace things out a bit.
.IP "\fB\-c\fR \fIconnect timeout\fR" 4
.IX Item "-c connect timeout"
In order avoid forking off lots of \fIssh\fR\|(1) processes that may never
come back, \fBnetrun\fR tries to connect to port 22 on each host in the
work list.  If a host takes longer than a default of 15 seconds to
respond, \fBnetrun\fR skips it.  This almost always works well, but if
the \s-1SSH\s0 server is linked with the \s-1TCP\s0 Wrapper library and the
nameservers are not responding, a timeout of at least two minutes
will be necessary.
.IP "\fB\-f\fR \fImax forks\fR" 4
.IX Item "-f max forks"
Specify the maximum number of background processes.  The default is 25.
.IP "\fB\-i\fR \fIinterpreter\fR" 4
.IX Item "-i interpreter"
Run the specified interpreter on the remote hosts.  The default is
\&\f(CW\*(C`/bin/sh\*(C'\fR.  The interpreter is only run if a script file or command
string is specified via \fB\-s\fR or \fB\-e\fR respectively.
.IP "\fB\-s\fR \fIscript file\fR" 4
.IX Item "-s script file"
Provide a local file containing a script to run on the remote hosts.
This script is sent to the specified interpreter's standard input.
The default interpreter is \f(CW\*(C`/bin/sh\*(C'\fR.
.IP "\fB\-e\fR \fIscript\fR" 4
.IX Item "-e script"
Like \fB\-s\fR, but the script source code is provided on the
command\-line, usually inside of single\-quotes.  This is handy for
small one-off runs.  If both \fB\-e\fR and \fB\-s\fR are specified, the
command string from \fB\-e\fR is sent first, followed by the contents of
the file specified with \fB\-s\fR.
.IP "\fB\-d\fR \fIdata file\fR" 4
.IX Item "-d data file"
Specify a local file to be appended to the end of the script.  When
the interpreter is \f(CW\*(C`perl\*(C'\fR, this is actually a convenient way to pass
parameters or data to the remote script.  Just make the first line of
the data file contains only \f(CW\*(C`_\|_DATA_\|_\*(C'\fR, and have the script read from
the \f(CW\*(C`DATA\*(C'\fR file handle.  It's actually necessary to do things this
way because the script source code is sent as standard input to the
remote interpreter; therefore there is no way to pass arguments on the
command\-line.  If \f(CW\*(C`\-\*(C'\fR is passed as the argument to \f(CW\*(C`\-d\*(C'\fR, \fBnetrun\fR
reads the data from standard input instead of a file.
.IP "\fB\-l\fR \fIlogin name\fR" 4
.IX Item "-l login name"
Specifies the user to log in as on the remote hosts.  By default, this
is the same as the user running \fBnetrun\fR.
.IP "\fB\-L\fR \fIlog dir\fR" 4
.IX Item "-L log dir"
Create log files in \fIlog dir\fR instead of \f(CW\*(C`./netrun.PID\*(C'\fR.  \fBNetrun\fR
creates two log files for each remote host:  \fIhostname\fR.err and
\&\fIhostname\fR.out
.Sp
The \fIhostname\fR.err file contains a few special fields written by
\&\fBnetrun\fR (used to create the status summary) as well as any messages
sent to standard error by the script while it was running on the
remote host.
.Sp
The \fIhostname\fR.out file simply contains any text that the remote
script wrote to standard output.
.IP "\fB\-t\fR \fItimeout\fR" 4
.IX Item "-t timeout"
Kill the remote script after timeout seconds.  By default, there is no
time limit.  The actual \s-1SSH\s0 process is sent a \f(CW\*(C`SIGHUP\*(C'\fR, which causes
it to shutdown the remote shell and kill the interpreter.  The exit
status reported by \fBnetrun\fR in the summary report will be \f(CW\*(C`\-1\*(C'\fR in
this case.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
The first few examples illustrate how \fBnetrun\fR works in terms of
equivalent shell operations.  Once you understand that, you'll know
the limitations of \fBnetrun\fR and how to best take advantage of its
capabilities.
.PP
The following two commands do basically the same thing, run \f(CW\*(C`uptime\*(C'\fR
on a remote host:
.PP
.Vb 2
\&   $ echo "uptime" | ssh fred.mydomain.com /bin/sh
\&   $ netrun -qe uptime fred.mydomain.com
.Ve
.PP
\&\fBNetrun\fR invokes an interpreter (default is \f(CW\*(C`/bin/sh\*(C'\fR) on each
remote host and then sends commands, scripts, and/or data to the
remote interpreter's standard input.  It works this way because most
of the time this eliminates the need to maintain a copy of your script
on each remote host.  For example:
.PP
.Vb 2
\&   $ cat my_script.pl | ssh fred.mydomain.com perl
\&   $ netrun -qi perl -s my_script.pl fred.mydomain.com
.Ve
.PP
The chief limitation of this approach is that you can't send
command-line arguments to your script.  In the case of \fBperl\fR
scripts; however, you can send \f(CW\*(C`DATA\*(C'\fR.  For example:
.PP
.Vb 2
\&   $ cat my_script.pl my_data.txt | ssh fred.mydomain.com perl
\&   $ netrun -qi perl -d my_data.txt -s my_script.pl fred.mydomain.com
.Ve
.PP
In this case, \f(CW\*(C`my_data.txt\*(C'\fR probably contains something like this:
.PP
.Vb 2
\&   __DATA__
\&   @ARGV = split " ", "-a -f /etc/init.d -v";
.Ve
.PP
In \f(CW\*(C`my_script.pl\*(C'\fR, there might be some (slightly dangerous) code like
this:
.PP
.Vb 1
\&   while ( <DATA> ) { eval $_ }
.Ve
.PP
Here is another somewhat silly example which shows that \fBnetrun\fR runs
the interpreter specified by \fB\-i\fR on each remote host, sending to
that interpreter's standard input the value of \fB\-e\fR followed by the
contents of the local file specified by \fB\-s\fR followed by the contents
of the local file specified by \fB\-d\fR:
.PP
.Vb 3
\&   $ netrun -i perl -e 'print "Hello, '`uname -n`'";' \e
\&                    -s my_script.pl \e
\&                    -d my_data.txt  fred.mydomain.com
.Ve
.PP
The above example prepends a \fBperl\fR print statement to the
\&\f(CW\*(C`my_script.pl\*(C'\fR script and tacks the contents of my_data.txt to the
end of it.  It sends the resulting concatenation to the standard input
of the \fBperl\fR process on each remote host, where hopefully it will do
something useful.
.PP
With that introduction, here are some hopefully more useful examples:
.PP
Tell \f(CW\*(C`inetd\*(C'\fR to re-read its configuration file on a bunch of Solaris hosts:
.PP
.Vb 5
\&   $ test -n "$SSHS_AGENT_PID" && kill -0 $SSHS_AGENT_PID \e
\&     || eval `ssh-agent`
\&   $ ssh-add -l | grep 'no identities' && ssh-add
\&   $ netrun -l root -e 'pkill -1 inetd' `cat hosts.lst`
\&   $ ssh-add -d
.Ve
.PP
Create a list of all systems on the local \s-1LAN\s0 that are running Oracle:
.PP
.Vb 3
\&   $ netrun -e 'ps -ef' -L Oracle 192.168.1.0/24
\&   $ grep -li oracle Oracle/*.out | sed 's/\e.out$//'
\&   $ rm -rf Oracle
.Ve
.PP
Same thing but shorter:
.PP
.Vb 1
\&   $ netrun -q -e 'ps -ef' 192.168.1.0/24 | grep -i oracle | cut -d: -f1
.Ve
.PP
Clone the local \f(CW\*(C`/etc/sudoers\*(C'\fR file out to a bunch of hosts (assumes
that you can sudo run \f(CW\*(C`tee\*(C'\fR and \f(CW\*(C`cksum\*(C'\fR and that you have the
\&\s-1NOPASSWD\s0 flag set):
.PP
.Vb 4
\&   $ sudo cat /etc/sudoers | netrun -q -d - -i '
\&        sudo tee /etc/sudoers > /dev/null
\&        sudo cksum /etc/sudoers' \e
\&     `cat hosts.lst`
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
ssh, sh, perl, grep, wfrun
.SH "AUTHOR"
.IX Header "AUTHOR"
David C. Snyder <David.Snyder@turner.com>
